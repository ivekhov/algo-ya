

def main():
    """
    Для чтения входных данных необходимо получить их
    из стандартного потока ввода (sys.stdin).
    Данные во входном потоке соответствуют описанному
    в условии формату. Обычно входные данные состоят
    из нескольких строк.
    Можно использовать несколько методов:
    * input() -- читает одну строку из потока без символа
    перевода строки;
    * sys.stdin.readline() -- читает одну строку из потока,
    сохраняя символ перевода строки в конце;
    * sys.stdin.readlines() -- вернет список (list) строк,
    сохраняя символ перевода строки в конце каждой из них.
    Чтобы прочитать из строки стандартного потока:
    * число -- int(input()) # в строке должно быть одно число
    * строку -- input()
    * массив чисел -- map(int, input().split())
    * последовательность слов -- input().split()
    Чтобы вывести результат в стандартный поток вывода (sys.stdout),
    можно использовать функцию print() или sys.stdout.write().
    Возможное решение задачи "Вычислите сумму чисел в строке":
    print(sum(map(int, input().split())))
    
    Если через файл, то:
    with open('input.txt') as f_in:
        f_in.readline().rstrip()
    
    with open('output.txt') as f_out:
        f_out.write()
    
    Дано целое число $n$. Требуется вывести все правильные скобочные последовательности длины $2\cdot n$, упорядоченные лексикографически (см. https://ru.wikipedia.org/wiki/Лексикографический_порядок). В задаче используются только круглые скобки.
    https://contest.yandex.ru/contest/8458/problems/D/
    
    Это пример относительно сложной алгоритмической задачи. Будем генерировать последовательность по одному символу; в каждый момент мы можем к текущей последовательности приписать либо открывающую скобку, либо закрывающую. Открывающую скобку можно дописать, если до этого было добавлено менее n открывающих скобок, а закрывающую — если в текущей последовательности количество открывающих скобок превосходит количество закрывающих. Такой алгоритм при аккуратной реализации автоматически гарантирует лексикографический порядок в ответе; работает за время, пропорциональное произведению количества элементов в ответе на n; при этом требует линейное количество дополнительной памяти.
    https://habr.com/ru/companies/yandex/articles/449890/

    """

    

    def func(n):
        res = []

        def inner(curr, open_cnt, close_cnt):
            
            if len(curr) == 2 * n:
                res.append(curr)
                return
            
            if open_cnt < n:
                inner(curr + '(', open_cnt + 1, close_cnt)

            if close_cnt < open_cnt:
                inner(curr + ')', open_cnt, close_cnt + 1)

        inner('', 0, 0)
        return res


    with open('input.txt', 'r') as f_in:
        n = int(f_in.readline().rstrip())

    sequences = func(n)



    with open('output.txt', 'w') as f_out:
        f_out.write('\n'.join(sequences))


if __name__ == '__main__':
    main()
