# Решето Эратосфена работает за O(n * log(log n)). # Алгоритм такой:# Выписываем все целые числа от 0 до n. Сразу помечаем, что числа 0 и 1 не являются простыми (записываем на соответствующих этим числам позициях False).# Заводим переменную num, равную первому не рассмотренному простому числу. Изначально она равна 2.# Помечаем в списке числа от 2⋅num до n с шагом, равным num, составными. Например, для 2 пометим значением False чётные числа — 4, 6, 8 и так далее.# Теперь в num присваиваем следующее простое число, то есть следующее не рассмотренное число в списке. # Для этого достаточно увеличивать num с шагом 1, пропуская числа, отмеченные как составные. На первом найденном простом числе следует остановиться.# Повторяем два предыдущих шага, пока это возможно.'''Существует метод решения задачи нахождения всех простых чисел, не превосходящих n, которому требуется O(n) операций. Он называется линейное решето. Этот метод помечает каждое число как составное только один раз.Как и прежде, мы будем перебирать числа в порядке увеличения. Только в отличие от классического решета Эратосфена, составные числа не вычёркиваются. Вместо этого для каждого числа x мы запишем наименьший простой делитель p. В программе мы будем записывать этот делитель в ячейку массива lp[x] (от англ. least prime).Если число простое, его наименьший простой делитель — оно само. Если число составное, его наименьший простой делитель p уже встречался раньше. Более того, нам встречалось и число i, такое, что x=i⋅p. На шаге i мы должны пометить число x как составное и указать его наименьший простой делитель.Каждое число будет помечено только один раз, на шаге i=x/p. Число i может быть взято только одним способом, потому что у любого числа существует только один наименьший простой делитель p.Алгоритм такой:Для каждого числа i будем хранить lp[i] — минимальный простой делитель числа i. Заведём массив lp длины n + 1. А также массив primes, в который будем добавлять найденные простые числа.Перебираем i по возрастанию.Если lp[i] = 0, можно сделать вывод, что число i простое, и добавить его в массив primes.Рассматриваем все простые числа p, которые не больше lp[i]. Обновляем lp[p * i] = p.'''def eratosphenes(n):    nums = list(range(n + 1))    nums[0] = False    nums[1] = False        for idx in range(2, n):        if nums[idx]:            for j in range(2 * idx, n + 1, idx):                nums[j] = False    return nums            def eratosphenes_effective(n):    nums = list(range(n + 1))    nums[0] = nums[1] = False    for idx in range(2, n):        if nums[idx]:            for j in range(idx * idx, n + 1, idx):                nums[j] = False    return nums    def get_least_prime(n):        # массив наименьших простых делителей     lp = [0] * (n + 1)        # массив простых чисел    primes = []        for i in range(2, n + 1):        if lp[i] == 0:            lp[i] = i            primes.append(i)        for p in primes:            x = p * i            if (x > n) or (p > lp[i]):                break            lp[x] = p    return primes, lp    def main():    n = 8    print(f'for {n}: eratospenes method prime numbers: {eratosphenes(n)}')    print(f'for {n}: eratospenes effective method prime numbers: {eratosphenes_effective(n)}')    print(f'for {n}: get_least_prime method prime numbers: {get_least_prime(n)}')if __name__ == '__main__':    main()