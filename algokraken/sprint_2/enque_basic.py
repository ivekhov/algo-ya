'''Создадим свой класс Queue. У объектов этого класса будут поля:queue — элементы очереди;head — индекс, по которому нужно извлекать элемент, если очередь не пустая;tail — индекс, по которому нужно добавлять элемент, если в очереди есть место;max_n — максимально возможное количество элементов в очереди;size — размер очереди.'''class Queue:	def __init__(self, n):		self.queue = [None] * n		self.head = 0		self.tail = 0		self.max_n = n		self.size = 0	def is_empty(self):		return self.size == 0					def push(self, x):		if self.size != self.max_n:			self.queue[self.tail] = x			# перестановка индекса головы на следующую позицию			# т к позиция в очереди размера n не м б больше n			# то поэтому индексы всегда от 0 до n (не включительно n):			self.tail = (self.tail + 1) % self.max_n			self.size += 1# После добавления элемента увеличиваем значение поля tail, # и новый элемент будет записываться в следующую ячейку. # Значение tail берётся по модулю max_n. Это делается для того, # чтобы первая ячейка следовала за последней. 	def pop(self):		if self.is_empty():			return None		x = self.queue[self.head]		self.queue[self.head] = None				# перестановка индекса головы на следующую позицию		# т к позиция в очереди размера n не м б больше n		# то поэтому индексы всегда от 0 до n (не включительно n):				self.head = (self.head + 1) % self.max_n				self.size -= 1		return xdef main():	q = Queue(8) 	q.push(1)	print(q.queue)  # [1, None, None, None, None, None, None, None]	print(q.size)   # 1	q.push(-1)	q.push(0)	q.push(11)	print(q.queue)  # [1, -1, 0, 11, None, None, None, None]	print(q.size)   # 4if __name__ == '__main__':	main()