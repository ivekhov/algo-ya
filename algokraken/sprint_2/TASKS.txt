# Задачи спринтаhttps://contest.yandex.ru/contest/22779/problems/# Финальные задачиhttps://contest.yandex.ru/contest/22781/problems/?nc=n5fQ6ZJuСдавайте решения в Яндекс Контесте, а когда получите ОК по обеим задачам, — запакуйте исходные файлы в один архив и загрузите на ревью. В начале каждого решения в комментарии:напишите объяснение, как было показано в предыдущем уроке;укажите ID успешной посылки, чтобы ревьюер мог удостовериться, что решение рабочее.Важно: выберите один язык программирования и сдавайте финальные задачи на ревью только на нём. Задачи, которые не требуют ревью, вы можете сдавать на любом из доступных языков.Как и в конце первого спринта, мы подготовили для вас финальные задачи. Однако теперь вам нужно будет не только решить их, но и объяснить эти решения вашему ревьюеру. О том, как это сделать, мы сейчас расскажем.Итак, в начале файла с решением, в комментариях:    • опишите принцип работы вашего алгоритма;    • обоснуйте, почему он должен работать корректно;    • оцените временную и пространственную сложность алгоритма.Если для объяснения вам потребуются дополнительные материалы (иллюстрации, вспомогательные тесты и т. п.), приложите файлы к архиву, либо укажите URL на ресурсы в интернете.Зачем объяснять свои решения?Комментарии нужны для сокращения количества итераций, для объективной оценки и для того, чтобы ревьюеру было легче понять ход ваших мыслей. Для вас же это прекрасная возможность поразмышлять над своими решениями, а ещё попрактиковаться в оценке их сложности и объяснении своей точки зрения — эти полезные навыки очень пригодятся вам на собеседованиях.Образец решения с комментариямиЗадача. Реализуйте структуру данных «очередь» (по принципу FIFO), используя из уже готовых структур только стеки.Очередь должна поддерживать следующие методы:    • put() — добавить элемент,    • get() — извлечь самый «старый» элемент,    • get_size() — вернуть текущий размер очереди.Сделайте очередь эффективной — амортизированная стоимость каждой операции не должна превышать O(1).Решение:/*-- ПРИНЦИП РАБОТЫ --Я реализовал очередь на двух стеках -- входном и выходном.Все добавляемые в очередь элементы добавляются во входной стек.Все извлекаемые из очереди элементы извлекаются из выходного стека.Если на момент извлечения из очереди выходной стек пуст,то последовательно перекладываю все элементы из входного стека в выходной,соответственно они перекладываются в обратном порядке.Я вдохновился идеей решения из статьи https://habr.com/ru/post/483944/-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --Из описания алгоритма следует, что чем раньше элемент добавился в очередь,тем раньше он будет из неё извлечён.Выходной стек хранит элементы в порядке, обратном тому,в каком они пришли во входной.Стек -- это порядок LIFO, а очередь -- это FIFO.Стек инвертирует порядок элементов: первые становятся последними.Так как у нас используются два стека, порядок меняется дважды,в итоге мы возвращаем элементы в исходном порядке.-- ВРЕМЕННАЯ СЛОЖНОСТЬ --Добавление в очередь стоит O(1), потому что добавление во входной стек стоит O(1).Извлечение из очереди стоит в лучшем случае O(1), когда выходной стек не пуст.В худшем случае извлечение стоит O(n), когда выходной стек пуст,и тогда требуется переложить все элементы из входного стека в выходной.Оценим сложность извлечения из очереди в среднем:Каждый элемент будет переложен из стека в стек ровно один раз.Это значит, что добавление и извлечение n элементов в сумме будет стоить O(n).В среднем получаем O(n) / n ~ O(1) -- амортизированная сложность.-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --Если очередь содержит n элементов, то входной стек содержит n1 элементов,и выходной стек содержит n2 элементов, причём n1 + n2 = nСтек, содержащий k элементов, занимает O(k) памяти.Поэтому и моя очередь будет потреблять O(n1) + O(n2) = O(n) памяти.*/