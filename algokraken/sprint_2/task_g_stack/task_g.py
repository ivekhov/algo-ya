# https://contest.yandex.ru/contest/22779/problems/G/?success=140723411#2989/2020_04_22/C27gKKeerr'''Реализуйте класс StackMaxEffective, поддерживающий операцию определения максимума среди элементов в стеке. Сложность операции должна быть O(1). Для пустого стека операция должна возвращать None. При этом push(x) и pop() также должны выполняться за константное время.Формат вводаВ первой строке записано одно число — количество команд, оно не превосходит 100000100000. Далее идут команды по одной в строке. Команды могут быть следующих видов:push(x) — добавить число pop() — удалить число с вершины стека;get_max() — напечатать максимальное число в стеке;top() — напечатать число с вершины стека;Если стек пуст, при вызове команды get_max нужно напечатать «None», для команды pop и top — «error».Что нового:1) Прием состоит в том, чтобы вести второй стек с максимальными значениямиосновного стека. Это позволит не искать максимальное значение каждый разпри вызове метода get_max()2) (!) наполнение второго стека - последним значением в этом же стеке, если в основной стек поступает значение меньшее, чем текущий максимум3) (!) в втором стеке значения строго по возрастанию - так гарантируется вечный максимум при обращении к вершине4) длина второго стека - такая же, как и у первого, это позволяет не выходить за пределы массива при снятии переменной со стека5) и не нужен внутренний атрибут у класса self.max - достаточнообращаться к последнему элементу списка6) Наполненность списка в Питоне может проверяться if self.items(), не прибегая к len() и тд8) при работе со структурами данных при отладке всегда создавать в репле объект класса и проверять на нем методы и свойства Пример:стек	доп стек с макс4		55		53		44		4заполнение снизу вверх ^'''from time import timeclass StackMaxEffective:	def __init__(self):		self.items = list()		self.inner_stack = list()	def push(self, x):		self.items.append(x)		if not self.inner_stack or x >= self.inner_stack[-1]:			self.inner_stack.append(x)		else:			self.inner_stack.append(self.inner_stack[-1])	def pop(self):		if self.items:			self.inner_stack.pop()			return self.items.pop()		def get_max(self):		return self.inner_stack[-1] if self.inner_stack else None	def size(self):		return len(self.items)	def top(self):		return self.items[-1]def main():	with open('input.txt', 'r') as f:		cnt = int(f.readline().rstrip())		stack = StackMaxEffective()		with open ('output.txt', 'w') as f_out:			for _ in range(cnt):				call = f.readline().rstrip().split(' ')				if call[0] == 'push':					stack.push(int(call[1]))				elif call[0] == 'pop':					if stack.size() == 0:						f_out.write('error\n')					else:						stack.pop()				elif call[0] == 'top':					if stack.size() == 0:						f_out.write('error\n')					else:						f_out.write(f'{str(stack.top())}\n')				elif call[0] == 'get_max':					if stack.size() == 0:						f_out.write('None\n')					else:						f_out.write(f'{str(stack.get_max())}\n')if __name__ == '__main__':# 	time_start = time()	main()# 	time_end = time()# 	time_duration = time_end - time_start# 	print(f'Took {time_duration} seconds')