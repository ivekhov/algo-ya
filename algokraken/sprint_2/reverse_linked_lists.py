import osLOCAL = os.environ.get('REMOTE_JUDGE', 'false') != 'true'if LOCAL:	class DoubleConnectedNode:  		def __init__(self, value, next=None, prev=None):  			self.value = value  			self.next = next			self.prev = prevdef print_nodes(node):	while node:		print(node.value, end=' -> ')		node = node.next	print('None')# неправильный способ!def solution_wrong(node):	curr_node = node	new_head = None	while curr_node:		curr_node.next = curr_node.prev		curr_node.prev = curr_node.next		new_head = curr_node		curr_node = curr_node.prev		return new_head## правильный способdef solution(node):	curr_node = node	new_head = None	while curr_node:					curr_node.next, curr_node.prev = curr_node.prev, curr_node.next# или так# 		temp = curr_node.next# 		curr_node.next = curr_node.prev# 		curr_node.prev = temp				new_head = curr_node		curr_node = curr_node.prev		return new_headdef reverse_list_double_connected(head):	curr_node = head	prev_node = None	new_head = None	while curr_node:		# 		curr_node.prev, curr_node.next = curr_node.next, curr_node.prev# or this explicitely:# 		temp = curr_node.next# 		curr_node.next = curr_node.prev# 		curr_node.prev = temp				new_head = curr_node		curr_node = curr_node.prev			return new_head#########def solution_onedirection(head):	curr_node = head	prev = None# 	new_head = None		while curr_node:		next_node = curr_node.next		curr_node.next = prev		prev = curr_node		curr_node = next_node# если с отдельной переменной головы списка# 		...# 		new_head = prev# 	new_head = prev# 	return new_head# если без переменной головы списка	return prev# repeat:def reverse_list_one_connected(head):	curr_node = head	new_head = None	prev_node = None		while curr_node:		next_node = curr_node.next		curr_node.next = prev_node		prev_node = curr_node		curr_node = next_node 			new_head = prev_node		return prev_node# repeatingdef reverse_oneway_linked_list(head):	print(f'head: {head.value}')	new_head = None	prev_node = None	curr_node = head	while curr_node:		next_node = curr_node.next		curr_node.next = prev_node				prev_node = curr_node		curr_node = next_node		new_head = prev_node		print(f'new_head: {new_head.value}')	return new_head# repeatingdef reverse_twoway_linked_list(head):	curr_node = head	new_head = None		while curr_node:# 		curr_node.prev, curr_node.next = curr_node.next, curr_node.prev		temp = curr_node.next		curr_node.next = curr_node.prev		curr_node.prev = temp		new_head = curr_node		curr_node = curr_node.prev			return new_headdef test():	node3 = DoubleConnectedNode("node3")	node2 = DoubleConnectedNode("node2")	node1 = DoubleConnectedNode("node1")	node0 = DoubleConnectedNode("node0")	node0.next = node1		node1.prev = node0	node1.next = node2		node2.prev = node1	node2.next = node3		node3.prev = node2		print_nodes(node0)		new_head = reverse_oneway_linked_list(node0)	print_nodes(node3)		# 	new_head = solution(node0)# 	new_head = reverse_list_double_connected(node0)# 	print_nodes(node3)# 	new_head = reverse_list_one_connected(node0)# 	print_nodes(node3)				# 	assert new_head is node3# 	assert node3.next is node2# 	assert node2.next is node1# 	assert node1.next is node0# # 	assert node2.prev is node3# 	assert node1.prev is node2# 	assert node0.prev is node1	if __name__ == '__main__':	test()    