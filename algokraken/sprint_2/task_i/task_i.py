class MyQueueSized():	def __init__(self, max_size):		self.queue = [None] * max_size		self.max_size = max_size		self.head = 0		self.tail = 0		self.size = 0	def push(self, item):		if self.max_size != self.size:			self.queue[self.tail] = item					self.tail = (self.tail + 1) % self.max_size			self.size += 1	def pop(self):		if self.size != 0:					item = self.queue[self.head]			self.queue[self.head] = None			self.head = (self.head + 1) % self.max_size			self.size -= 1			return item		def peek(self):		return self.queue[self.head]		def size(self):		return self.size		def is_empty(self):		return self.size == 0def main():	with open('input.txt', 'r') as f:		cnt = int(f.readline().rstrip())		max_size = int(f.readline().rstrip())		queue = MyQueueSized(max_size)		with open('output.txt', 'w') as f_out:			for _ in range(cnt):				commands = f.readline().rstrip().split(' ')				if commands[0] == 'push':					if queue.size != max_size:						queue.push(int(commands[1]))					else:						f_out.write('error\n')				elif commands[0] == 'pop':					if queue.is_empty():						res = 'None'					else:						res = queue.pop()								f_out.write(f'{str(res)}\n')				elif commands[0] == 'peek':					if queue.is_empty():						res = 'None'					else:						res = queue.peek()					f_out.write(f'{str(res)}\n')				elif commands[0] == 'size':					f_out.write(f'{str(queue.size)}\n')if __name__ == '__main__':	main()